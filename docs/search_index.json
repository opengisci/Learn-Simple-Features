[["index.html", "Learn Simple Features for Spatial Analysis in R Chapter 1 Introduction 1.1 Abstract 1.2 Study Metadata 1.3 Hello, Central Falls world", " Learn Simple Features for Spatial Analysis in R Joseph Holler 2025-02-13 Chapter 1 Introduction 1.1 Abstract This project is a resource for learning geographic analysis using primarily vector data with the sf for R. To do so, we use a simplified teaching data set inspired by the city of Central Falls, Rhode Island. 1.2 Study Metadata Key words: Central Falls, sf, vector analysis, teaching demonstration Subject: Social and Behavioral Sciences: Geography: Geographic Information Sciences Date created: 2025-02-12 Date modified: 2025-02-12 Spatial Coverage: Central Falls, Rhode Island, OSM:191213 Spatial Resolution: 250 meters Spatial Reference System: EPSG:6567 NAD83(2011) / Rhode Island Temporal Coverage: N/A Temporal Resolution: N/A 1.3 Hello, Central Falls world Let’s read a reference point grid from the geopackage cf_given in the layer pointgrid. As we read the data in, we’ll recalculate x- and y- offsets for label placement in tmap. Those offsets worked well to place the grid reference letters and numbers just outside the grid in QGIS layouts, but they need to be adjusted to achieve the same placements in tmap. pointgrid &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_given.gpkg&quot;), layer=&quot;pointgrid&quot;) |&gt; mutate(xOff = xOff / 4, yOff = yOff / -4, order = case_when( order == 0 ~ 0.5, .default = order )) ## Reading layer `pointgrid&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_given.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 81 features and 8 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88292.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island As we load the data, sf reports some basic geographic metadata about the layer, including the geometry type, bounding box (geographic extent), and coordinate reference system. Let’s display the grid. We make the bbox equal to a buffered pointgrid to add some margin space to the map figure. pointgrid_map &lt;- pointgrid |&gt; tm_shape(bbox = st_buffer(pointgrid, 250)) + tm_symbols(border.alpha = 0.5, alpha = 0, size = &quot;order&quot;, legend.size.show = FALSE) + tm_text(&quot;label&quot;, ymod=&quot;yOff&quot;, xmod=&quot;xOff&quot;, col=&quot;grey50&quot;) pointgrid_map Let’s read a layer of Central Falls zones, the local geographic unit of enumeration and neighborhood governance. zones &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_digitized.gpkg&quot;), layer=&quot;zones&quot;) ## Reading layer `zones&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_digitized.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 4 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88292.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island Let’s inspect the zones attribute table. zones |&gt; st_drop_geometry() |&gt; knitr::kable() zone pop minority poverty NW 5300 4300 2000 NE 4800 3800 1350 SE 4400 3200 1400 SW 4600 3600 1300 Notice how the id column has been converted into row labels. There are four other columns: zone is character string with the zone name based on compass direction. pop is an integer count of the total population minority is an integer count of the population reporting as any minority identity on the census poverty is an integer count of the population with household income below the poverty level Let’s map the zones. zones_map &lt;- zones |&gt; tm_shape() + tm_polygons(border.col = &quot;grey30&quot;, lwd = 2, lty = &quot;dashed&quot;, alpha = 0) + tm_text(&quot;zone&quot;, col=&quot;grey30&quot;) pointgrid_map + zones_map Let’s load in the parks. parks &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_digitized.gpkg&quot;), layer=&quot;parks&quot;) ## Reading layer `parks&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_digitized.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 5 features and 1 field ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88792.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island Let’s inspect the parks attribute table. parks |&gt; st_drop_geometry() |&gt; knitr::kable() park Blackstone Spintex Macomber Jenks FC There is just one field, park, containing the park names. Let’s map the parks. working_color = &quot;darkgreen&quot; parks_map &lt;- parks |&gt; tm_shape() + tm_polygons(border.col = working_color, lwd = 2, col = working_color, alpha = 0.5) + tm_text(&quot;park&quot;, col=working_color, along.lines = TRUE) pointgrid_map + parks_map Let’s load in the watersheds watersheds &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_digitized.gpkg&quot;), layer=&quot;watersheds&quot;) ## Reading layer `watersheds&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_digitized.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 3 features and 1 field ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88292.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island Let’s inspect the watersheds attribute table. watersheds |&gt; st_drop_geometry() |&gt; knitr::kable() name Moshassuck Narragansett Blackstone Let’s map the watersheds. working_color = &quot;royalblue3&quot; watersheds_map &lt;- watersheds |&gt; tm_shape() + tm_polygons(border.col = working_color, lwd = 2, col = working_color, alpha = 0.2) + tm_text(&quot;name&quot;, col=working_color, along.lines = TRUE) pointgrid_map + watersheds_map "],["area-weighted-re-aggregation.html", "Chapter 2 Area-weighted re-aggregation 2.1 Calculate source areas 2.2 Disaggregate 2.3 Reaggregate", " Chapter 2 Area-weighted re-aggregation Suppose that we need to summarize population data from zones in the boundaries of the watersheds. We only have one commonality between the two layers: geographic location. To make matters more complicated, the boundaries are not neatly nested within one another. In order to move data from the zones into the watersheds, we must assume that the population (and variables thereof) are equally distributed across the space of the zones. 2.1 Calculate source areas zones &lt;- mutate(zones, s_area = st_area(geom)) 2.2 Disaggregate Let’s use the st_intersection operation to overlay zones and watersheds. fragments &lt;- st_intersection(zones, watersheds) Resulting in the table… fragments |&gt; st_drop_geometry() |&gt; knitr::kable() zone pop minority poverty s_area name 1 NW 5300 4300 2000 875000 [m^2] Moshassuck 4 SW 4600 3600 1300 1000000 [m^2] Moshassuck 3 SE 4400 3200 1400 1000000 [m^2] Narragansett 4.1 SW 4600 3600 1300 1000000 [m^2] Narragansett 1.1 NW 5300 4300 2000 875000 [m^2] Blackstone 2 NE 4800 3800 1350 1000000 [m^2] Blackstone 3.1 SE 4400 3200 1400 1000000 [m^2] Blackstone 4.2 SW 4600 3600 1300 1000000 [m^2] Blackstone and the map… pointgrid_map + fragments |&gt; rownames_to_column(var = &quot;id&quot;) |&gt; tm_shape() + tm_polygons(alpha = 0.5) + tm_text(&quot;id&quot;) Now, calculate area-weighted estimates. We use an as.numeric function to discard the units data of m^2. fragments &lt;- mutate(fragments, f_area = st_area(geom), aw = as.numeric(f_area / s_area), aw_pop = aw * pop, aw_minor = aw * minority, aw_pov = aw * poverty) fragments |&gt; st_drop_geometry() |&gt; knitr::kable() zone pop minority poverty s_area name f_area aw aw_pop aw_minor aw_pov 1 NW 5300 4300 2000 875000 [m^2] Moshassuck 281250 [m^2] 0.3214286 1703.571 1382.143 642.8571 4 SW 4600 3600 1300 1000000 [m^2] Moshassuck 750000 [m^2] 0.7500000 3450.000 2700.000 975.0000 3 SE 4400 3200 1400 1000000 [m^2] Narragansett 468750 [m^2] 0.4687500 2062.500 1500.000 656.2500 4.1 SW 4600 3600 1300 1000000 [m^2] Narragansett 125000 [m^2] 0.1250000 575.000 450.000 162.5000 1.1 NW 5300 4300 2000 875000 [m^2] Blackstone 593750 [m^2] 0.6785714 3596.429 2917.857 1357.1429 2 NE 4800 3800 1350 1000000 [m^2] Blackstone 1000000 [m^2] 1.0000000 4800.000 3800.000 1350.0000 3.1 SE 4400 3200 1400 1000000 [m^2] Blackstone 531250 [m^2] 0.5312500 2337.500 1700.000 743.7500 4.2 SW 4600 3600 1300 1000000 [m^2] Blackstone 125000 [m^2] 0.1250000 575.000 450.000 162.5000 2.3 Reaggregate Now it’s time to re-aggregate into watersheds. In R, we accomplish this by grouping with group_by and summarizing with summarize. We dissolve the polygons together with st_union. watersheds_pop &lt;- fragments |&gt; group_by(name) |&gt; summarize( sumpop = sum(aw_pop), summinor = sum(aw_minor), sumpov = sum(aw_pov), geom = st_union(geom) ) Let’s calculate the percentage minority and percentage below poverty and view the resulting attribute table. watersheds_pop &lt;- mutate(watersheds_pop, pctminority = round(summinor / sumpop * 100, 1), pctpov = round(sumpov / sumpop * 100, 1)) watersheds_pop |&gt; st_drop_geometry() |&gt; knitr::kable() name sumpop summinor sumpov pctminority pctpov Blackstone 11308.929 8867.857 3613.393 78.4 32.0 Moshassuck 5153.571 4082.143 1617.857 79.2 31.4 Narragansett 2637.500 1950.000 818.750 73.9 31.0 And map the percentage in poverty in watersheds. pointgrid_map + watersheds_pop |&gt; tm_shape() + tm_polygons(col = &quot;pctminority&quot;, alpha = 0.5, legend.show = FALSE) + tm_text(&quot;pctminority&quot;) Another approach could have summarized the attribute data without the geometry data, and then joined the summaries back to the watersheds by attribute. First, drop the geometry data and summarize the attribute data. watersheds_sum &lt;- fragments |&gt; st_drop_geometry() |&gt; group_by(name) |&gt; summarize( sumpop = sum(aw_pop), summinor = sum(aw_minor), sumpov = sum(aw_pov) ) watersheds_sum |&gt; knitr::kable() name sumpop summinor sumpov Blackstone 11308.929 8867.857 3613.393 Moshassuck 5153.571 4082.143 1617.857 Narragansett 2637.500 1950.000 818.750 Next, join the data to watersheds by attribute. watersheds_pop &lt;- watersheds |&gt; left_join(watersheds_sum, by = join_by(name)) |&gt; mutate(pctminority = round(summinor / sumpop * 100, 1), pctpov = round(sumpov / sumpop * 100, 1)) watersheds_pop |&gt; st_drop_geometry() |&gt; knitr::kable() name sumpop summinor sumpov pctminority pctpov Moshassuck 5153.571 4082.143 1617.857 79.2 31.4 Narragansett 2637.500 1950.000 818.750 73.9 31.0 Blackstone 11308.929 8867.857 3613.393 78.4 32.0 And map the percentage in poverty in watersheds. pointgrid_map + watersheds_pop |&gt; tm_shape() + tm_polygons(col = &quot;pctminority&quot;, alpha = 0.5, legend.show = FALSE) + tm_text(&quot;pctminority&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
