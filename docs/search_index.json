[["index.html", "Learn Simple Features for Spatial Analysis in R Chapter 1 Introduction 1.1 Abstract 1.2 Study Metadata 1.3 Computational environment in R 1.4 Hello, Central Falls world", " Learn Simple Features for Spatial Analysis in R Joseph Holler 2025-02-16 Chapter 1 Introduction 1.1 Abstract This project is a resource for learning geographic analysis using primarily vector data with the sf for R. To do so, we use a simplified teaching data set inspired by the city of Central Falls, Rhode Island. 1.2 Study Metadata Key words: Central Falls, sf, vector analysis, teaching demonstration Subject: Social and Behavioral Sciences: Geography: Geographic Information Sciences Date created: 2025-02-12 Date modified: 2025-02-12 Spatial Coverage: Central Falls, Rhode Island, OSM:191213 Spatial Resolution: 250 meters Spatial Reference System: EPSG:6567 NAD83(2011) / Rhode Island 1.3 Computational environment in R We set up a computational environment for spatial analysis in R using the groundhog package. This package allows you to specify a date at which the analysis was developed and a list of packages required. From there, groundhog checks for a version of R appropriate for that date and installs the latest versions of the required packages as of that date. This is particularly important in the context of spatial data science because the packages we use have a history of major version upgrades without backward capability. For example, version 4.0 of the tmap package for thematic mapping cannot be used to run all code written for version 3: most of the code will work with warnings, but not all. In this book, we use: here to manage reproducible file paths tidyverse for data wrangling and graphing sf for vector data and algorithms aligned with the simple features standards tmap for cartography lwgeom for minimum bounding circles and geodesic calculations The code block below may need to be run multiple times to get the full environment working. You may also need to respond to prompts and warnings output to the console, including: ok for permission to write groundhog files to the groundhog folder install the correct version of R for the time given and start an R session with that version restart the R session and re-run the code block packages &lt;- c(&quot;here&quot;, &quot;tidyverse&quot;, &quot;sf&quot;, &quot;tmap&quot;, &quot;lwgeom&quot;, &quot;kableExtra&quot;) # force all conflicts to become errors # if you load dplyr and use filter(), R has to guess whether you mean dplyr::filter() or stats::filter() # the conflicted package forces you to be explicit about this # disable at your own peril # https://conflicted.r-lib.org/ require(conflicted) # load and install required packages # https://groundhogr.com/ if (!require(groundhog)) { install.packages(&quot;groundhog&quot;) require(groundhog) } # this date will be used to determine the versions of R and your packages # it is best practice to keep R and its packages up to date groundhog.day &lt;- &quot;2025-02-01&quot; # you may want to use set.groundhog.folder() to choose where to install packages under groundhog # the folder should be on the same drive as your R installation, and should not be synced to the cloud # this replaces any library() or require() calls groundhog.library(packages, groundhog.day) # set up default knitr parameters: https://yihui.org/knitr/options/ knitr::opts_chunk$set( echo = TRUE, fig.retina = 4, fig.width = 8, fig.path = paste0(here(&quot;results&quot;, &quot;figures&quot;), &quot;/&quot;) ) Record the established computational environment for R. sessionInfo() # alternatively, use devtools::session_info() for better results writeLines( capture.output(sessionInfo()), here(&quot;procedure&quot;, &quot;environment&quot;, paste0(&quot;r-environment-&quot;, Sys.Date(), &quot;.txt&quot;)) ) knitr::write_bib(c(packages, c(&quot;knitr&quot;, &quot;bookdown&quot;, &quot;rmarkdown&quot;)), here(&#39;packages.bib&#39;)) 1.4 Hello, Central Falls world Let’s read a reference point grid from the geopackage cf_given in the layer pointgrid. As we read the data in, we’ll recalculate x- and y- offsets for label placement in tmap. Those offsets worked well to place the grid reference letters and numbers just outside the grid in QGIS layouts, but they need to be adjusted to achieve the same placements in tmap. pointgrid &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_given.gpkg&quot;), layer=&quot;pointgrid&quot;) |&gt; mutate(xOff = xOff / 4, yOff = yOff / -4, order = ifelse(order == 0, 0.5, order), label = ifelse(is.na(label), &quot;&quot;, label)) ## Reading layer `pointgrid&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_given.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 81 features and 8 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88292.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island As we load the data, sf reports some basic geographic metadata about the layer, including the geometry type, bounding box (geographic extent), and coordinate reference system. Let’s display the grid. We make the bbox equal to a buffered pointgrid to add some margin space to the map figure. pointgrid_map &lt;- pointgrid |&gt; tm_shape(bbox = st_buffer(pointgrid, 250)) + tm_symbols(col_alpha = 0.5, fill_alpha = 0, size = &quot;order&quot;, size.legend = tm_legend_hide()) + tm_text(&quot;label&quot;, ymod=&quot;yOff&quot;, xmod=&quot;xOff&quot;, col=&quot;grey50&quot;, fontfamily = &quot;mono&quot;) pointgrid_map Let’s read a layer of Central Falls zones, the local geographic unit of enumeration and neighborhood governance. zones &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_digitized.gpkg&quot;), layer=&quot;zones&quot;) ## Reading layer `zones&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_digitized.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 4 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88292.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island Let’s inspect the zones attribute table. zones |&gt; st_drop_geometry() |&gt; knitr::kable() zone pop minority poverty NW 5300 4300 2000 NE 4800 3800 1350 SE 4400 3200 1400 SW 4600 3600 1300 Notice how the id column has been converted into row labels. There are four other columns: zone is character string with the zone name based on compass direction. pop is an integer count of the total population minority is an integer count of the population reporting as any minority identity on the census poverty is an integer count of the population with household income below the poverty level Let’s map the zones. zones_map &lt;- zones |&gt; tm_shape() + tm_polygons(col = &quot;grey30&quot;, lwd = 2, lty = &quot;dashed&quot;, fill_alpha = 0) + tm_text(&quot;zone&quot;, col=&quot;grey30&quot;) pointgrid_map + zones_map Let’s load in the parks. parks &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_digitized.gpkg&quot;), layer=&quot;parks&quot;) ## Reading layer `parks&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_digitized.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 5 features and 1 field ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88792.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island Let’s inspect the parks attribute table. parks |&gt; st_drop_geometry() |&gt; knitr::kable() park Blackstone Spintex Macomber Jenks FC There is just one field, park, containing the park names. Let’s map the parks. working_color = &quot;darkgreen&quot; parks_map &lt;- parks |&gt; tm_shape() + tm_polygons(col = working_color, lwd = 2, fill = working_color, fill_alpha = 0.5) + tm_text(&quot;park&quot;, col = working_color) pointgrid_map + parks_map Let’s load in the watersheds watersheds &lt;- st_read(here(&quot;data&quot;, &quot;raw&quot;, &quot;public&quot;, &quot;cf_digitized.gpkg&quot;), layer=&quot;watersheds&quot;) ## Reading layer `watersheds&#39; from data source ## `C:\\git\\opengisci\\Learn-Simple-Features\\data\\raw\\public\\cf_digitized.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 3 features and 1 field ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 107710.4 ymin: 88292.71 xmax: 109710.4 ymax: 90292.71 ## Projected CRS: NAD83(2011) / Rhode Island Let’s inspect the watersheds attribute table. watersheds |&gt; st_drop_geometry() |&gt; knitr::kable() name Moshassuck Narragansett Blackstone Let’s map the watersheds. working_color = &quot;royalblue3&quot; watersheds_map &lt;- watersheds |&gt; tm_shape() + tm_polygons(col = working_color, lwd = 2, fill = working_color, fill_alpha = 0.2) + tm_text(&quot;name&quot;, col = working_color, ymod = -1, fontface = &quot;italic&quot;) pointgrid_map + watersheds_map "],["measuring-and-constructing-shapes.html", "Chapter 2 Measuring and constructing shapes 2.1 Area and Perimeter 2.2 Centroids 2.3 Point on surface 2.4 Convex hull 2.5 Minimum bounding circle", " Chapter 2 Measuring and constructing shapes Let’s practice using spatial functions to measure and characterize the shapes of polygons using the example of watersheds. All of these measurements are dependent upon the accuracy of the map projection in which the data is stored. Also, different from normal GIS, measurements produce a value with a unit in R! This can be helpful, but when it isn’t, it’s easy enough to convert back to a simple number with as.numeric(). 2.1 Area and Perimeter What is the area of each watershed? You’ll need to know which column stores the geographic geometry data. watersheds_shp &lt;- mutate(watersheds, warea = st_area(geom), wperim = st_perimeter(geom)) ## Warning: There was 1 warning in `stopifnot()`. ## ℹ In argument: `wperim = st_perimeter(geom)`. ## Caused by warning in `st_perimeter()`: ## ! &#39;st_perimeter&#39; is deprecated. ## Use &#39;sf::st_perimeter or lwgeom::st_perimeter_lwgeom&#39; instead. ## See help(&quot;Deprecated&quot;) watersheds_shp |&gt; st_drop_geometry() |&gt; knitr::kable() name warea wperim Moshassuck 1031250 [m^2] 4560.660 [m] Narragansett 593750 [m^2] 3353.553 [m] Blackstone 2375000 [m^2] 7914.214 [m] We can also calculate the compactness as a function of perimeter and area. The Polsby-Popper isoperimetric ratio is 4 * pi * A / P^2 watersheds_shp &lt;- mutate(watersheds_shp, compact = round( as.numeric( (4 * pi * warea) / wperim^2), 2)) watersheds_shp |&gt; st_drop_geometry() |&gt; knitr::kable() name warea wperim compact Moshassuck 1031250 [m^2] 4560.660 [m] 0.62 Narragansett 593750 [m^2] 3353.553 [m] 0.66 Blackstone 2375000 [m^2] 7914.214 [m] 0.48 Do the compactness scores make sense? Let’s map them. pointgrid_map + watersheds_shp |&gt; tm_shape() + tm_polygons(col = &quot;compact&quot;, alpha = 0.5, legend.show = FALSE) + tm_text(&quot;compact&quot;) ## ## ── tmap v3 code detected ────────────────────────────────────────────────────────────────────────────────────────────── ## [v3-&gt;v4] `tm_polygons()`: use &#39;fill&#39; for the fill color of polygons/symbols (instead of &#39;col&#39;), and &#39;col&#39; for the ## outlines (instead of &#39;border.col&#39;). ## [v3-&gt;v4] `tm_polygons()`: use `fill_alpha` instead of `alpha`. ## [v3-&gt;v4] `tm_polygons()`: use `fill.legend = tm_legend_hide()` instead of `legend.show = FALSE`. ## This message is displayed once every 8 hours. Looks good to me! 2.2 Centroids We also have a few methods for converting polygons to points. Centroids are located at the center of gravity of a polygon. watersheds_centroids &lt;- watersheds_shp |&gt; st_centroid() Map the centroid points as blue dots. watersheds_centroids_map &lt;- watersheds_centroids |&gt; tm_shape() + tm_symbols( size = 0.8, fill = &quot;blue&quot;, fill_alpha = 0.8 ) pointgrid_map + watersheds_map + watersheds_centroids_map 2.3 Point on surface Centroids sometimes fall outside of the polygon, which might produce undesirable results for cartography or topological analysis. In those cases point_on_surface may be better. watersheds_pt_on_surf &lt;- watersheds_shp |&gt; st_point_on_surface() Let’s see the points on surface in relation to the centroids. watersheds_points_on_surface_map &lt;- watersheds_pt_on_surf |&gt; tm_shape() + tm_symbols( size = 0.8, fill = &quot;white&quot;, fill_alpha = 0.8 ) pointgrid_map + watersheds_map + watersheds_centroids_map + watersheds_points_on_surface_map 2.4 Convex hull Some measures of gerrymandering rely on the ratio of the area to the area of the convex hull or of the minimum bounding circle (Niemi et al. 1990). Let’s calculate the convex hull. watersheds_hull &lt;- watersheds_shp |&gt; st_convex_hull() And visualize the resulting polygons. pointgrid_map + watersheds_map + tm_shape(watersheds_hull) + tm_polygons( col = &quot;white&quot;, lwd = 3, lty = &quot;dotted&quot;, fill = &quot;red&quot;, fill_alpha = 0.2 ) How would the ratios of area to area of the convex hull come out? The watersheds contributing to more overlapping areas whould result in lower compactness scores. watersheds_hull &lt;- mutate(watersheds_hull, compact_hull = round(as.numeric(warea / st_area(geom)), 2)) watersheds_hull |&gt; st_drop_geometry() |&gt; knitr::kable() name warea wperim compact compact_hull Moshassuck 1031250 [m^2] 4560.660 [m] 0.62 1.00 Narragansett 593750 [m^2] 3353.553 [m] 0.66 0.90 Blackstone 2375000 [m^2] 7914.214 [m] 0.48 0.82 2.5 Minimum bounding circle Another method of measuring compactness is to find the ratio of the area of the polygon and divide it by the area of its minimum bounding circle (Reock 1961). Let’s find the minimum bounding circles of watersheds. This function is not yet included in the current sf package on CRAN, but it is in lwgeom. watersheds_boundcircle &lt;- watersheds_shp |&gt; st_minimum_bounding_circle() Let’s map the resulting circle polygons. pointgrid_map + watersheds_map + tm_shape(watersheds_boundcircle) + tm_polygons( col = &quot;white&quot;, lwd = 3, lty = &quot;dotted&quot;, fill = &quot;red&quot;, fill_alpha = 0.2 ) Finally, let’s calculate the ratio of area of the polygon to the area of its minimum bounding circle. watersheds_boundcircle &lt;- mutate(watersheds_boundcircle, compact_circ = round(as.numeric(warea / st_area(geom)), 2)) watersheds_boundcircle |&gt; st_drop_geometry() |&gt; knitr::kable() name warea wperim compact compact_circ Moshassuck 1031250 [m^2] 4560.660 [m] 0.62 0.36 Narragansett 593750 [m^2] 3353.553 [m] 0.66 0.48 Blackstone 2375000 [m^2] 7914.214 [m] 0.48 0.38 "],["area-weighted-re-aggregation.html", "Chapter 3 Area-weighted re-aggregation 3.1 Calculate source areas 3.2 Disaggregate 3.3 Reaggregate", " Chapter 3 Area-weighted re-aggregation Suppose that we need to summarize population data from zones in the boundaries of the watersheds. We only have one commonality between the two layers: geographic location. To make matters more complicated, the boundaries are not neatly nested within one another. In order to move data from the zones into the watersheds, we must assume that the population (and variables thereof) are equally distributed across the space of the zones. 3.1 Calculate source areas zones &lt;- mutate(zones, s_area = st_area(geom)) 3.2 Disaggregate Let’s use the st_intersection operation to overlay zones and watersheds. fragments &lt;- st_intersection(zones, watersheds) Resulting in the table… fragments |&gt; st_drop_geometry() |&gt; knitr::kable() zone pop minority poverty s_area name 1 NW 5300 4300 2000 875000 [m^2] Moshassuck 4 SW 4600 3600 1300 1000000 [m^2] Moshassuck 3 SE 4400 3200 1400 1000000 [m^2] Narragansett 4.1 SW 4600 3600 1300 1000000 [m^2] Narragansett 1.1 NW 5300 4300 2000 875000 [m^2] Blackstone 2 NE 4800 3800 1350 1000000 [m^2] Blackstone 3.1 SE 4400 3200 1400 1000000 [m^2] Blackstone 4.2 SW 4600 3600 1300 1000000 [m^2] Blackstone and the map… pointgrid_map + fragments |&gt; rownames_to_column(var = &quot;id&quot;) |&gt; tm_shape() + tm_polygons(fill_alpha = 0.5) + tm_text(&quot;id&quot;) Now, calculate area-weighted estimates. We use an as.numeric function to discard the units data of m^2. fragments &lt;- mutate(fragments, f_area = st_area(geom), aw = as.numeric(f_area / s_area), aw_pop = aw * pop, aw_minor = aw * minority, aw_pov = aw * poverty) fragments |&gt; st_drop_geometry() |&gt; knitr::kable(digits = 2) |&gt; kable_styling() |&gt; scroll_box(width = &quot;100%&quot;, box_css = &quot;border: 0px;&quot;) zone pop minority poverty s_area name f_area aw aw_pop aw_minor aw_pov 1 NW 5300 4300 2000 875000 [m^2] Moshassuck 281250 [m^2] 0.32 1703.57 1382.14 642.86 4 SW 4600 3600 1300 1000000 [m^2] Moshassuck 750000 [m^2] 0.75 3450.00 2700.00 975.00 3 SE 4400 3200 1400 1000000 [m^2] Narragansett 468750 [m^2] 0.47 2062.50 1500.00 656.25 4.1 SW 4600 3600 1300 1000000 [m^2] Narragansett 125000 [m^2] 0.12 575.00 450.00 162.50 1.1 NW 5300 4300 2000 875000 [m^2] Blackstone 593750 [m^2] 0.68 3596.43 2917.86 1357.14 2 NE 4800 3800 1350 1000000 [m^2] Blackstone 1000000 [m^2] 1.00 4800.00 3800.00 1350.00 3.1 SE 4400 3200 1400 1000000 [m^2] Blackstone 531250 [m^2] 0.53 2337.50 1700.00 743.75 4.2 SW 4600 3600 1300 1000000 [m^2] Blackstone 125000 [m^2] 0.12 575.00 450.00 162.50 3.3 Reaggregate Now it’s time to re-aggregate into watersheds. In R, we accomplish this by grouping with group_by and summarizing with summarize. We dissolve the polygons together with st_union. Based on this, it may note be required to explicitly specify geom = st_union(geom) https://bookdown.org/robinlovelace/geocompr/geometric-operations.html watersheds_pop &lt;- fragments |&gt; group_by(name) |&gt; summarize( sumpop = sum(aw_pop), summinor = sum(aw_minor), sumpov = sum(aw_pov), geom = st_union(geom) ) Let’s calculate the percentage minority and percentage below poverty and view the resulting attribute table. watersheds_pop &lt;- mutate(watersheds_pop, pctminority = round(summinor / sumpop * 100, 1), pctpov = round(sumpov / sumpop * 100, 1)) watersheds_pop |&gt; st_drop_geometry() |&gt; knitr::kable(digits = 2) name sumpop summinor sumpov pctminority pctpov Blackstone 11308.93 8867.86 3613.39 78.4 32.0 Moshassuck 5153.57 4082.14 1617.86 79.2 31.4 Narragansett 2637.50 1950.00 818.75 73.9 31.0 And map the percentage in poverty in watersheds. pointgrid_map + watersheds_pop |&gt; tm_shape() + tm_polygons(fill = &quot;pctminority&quot;, fill_alpha = 0.5, fill.legend = tm_legend_hide()) + tm_text(&quot;pctminority&quot;) Another approach could have summarized the attribute data without the geometry data, and then joined the summaries back to the watersheds by attribute. First, drop the geometry data and summarize the attribute data. watersheds_sum &lt;- fragments |&gt; st_drop_geometry() |&gt; group_by(name) |&gt; summarize( sumpop = sum(aw_pop), summinor = sum(aw_minor), sumpov = sum(aw_pov) ) watersheds_sum |&gt; knitr::kable(digits = 1) name sumpop summinor sumpov Blackstone 11308.9 8867.9 3613.4 Moshassuck 5153.6 4082.1 1617.9 Narragansett 2637.5 1950.0 818.8 Next, join the data to watersheds by attribute. watersheds_pop &lt;- watersheds |&gt; left_join(watersheds_sum, by = join_by(name)) |&gt; mutate(pctminority = round(summinor / sumpop * 100, 1), pctpov = round(sumpov / sumpop * 100, 1)) watersheds_pop |&gt; st_drop_geometry() |&gt; knitr::kable(digits = 1) name sumpop summinor sumpov pctminority pctpov Moshassuck 5153.6 4082.1 1617.9 79.2 31.4 Narragansett 2637.5 1950.0 818.8 73.9 31.0 Blackstone 11308.9 8867.9 3613.4 78.4 32.0 And map the percentage of people in poverty in watersheds. pointgrid_map + watersheds_pop |&gt; tm_shape() + tm_polygons(fill = &quot;pctminority&quot;, fill_alpha = 0.5, fill.legend = tm_legend_hide()) + tm_text(&quot;pctminority&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
